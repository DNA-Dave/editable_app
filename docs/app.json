[{"name": "app.py", "content": "import asyncio\nimport pandas as pd\nfrom datetime import date\nfrom datetime import datetime\nfrom utils import get_guides\nfrom shiny import App, render, ui, reactive\n\nimport numpy as np\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\naccepted_bases = {\"A\", \"C\", \"G\", \"T\", \"-\"}\n\n# A card component wrapper.\ndef ui_card(title, *args):\n    return (\n        ui.div(\n            {\"class\": \"card mb-4\"},\n            ui.div(title, class_=\"card-header\"),\n            ui.div({\"class\": \"card-body\"}, *args),\n        ),\n    )\n\napp_ui = ui.page_fluid(\n    {\"id\": \"main-content\"},\n    ui.panel_title('editABLE'),\n    ui.br(),\n    ui.help_text(\n        '''Welcome to editABLE! This Shiny app was built primarily to find CRISPR base editing guides, \n         but can also do a first pass analysis to find prime editing guides.'''),\n    ui.br(),\n    ui.br(),\n    ui_card(\n        \"How to use this app\",\n        ui.help_text(\n            '''In CRISPR editing experiments, one is trying to induce some change in a DNA sequence.\n             Therefore, you have a reference sequence (the original sequence you are trying to change)\n             and a edited sequence (what you want your sequence to look like after the CRISPR edit).'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"There are two ways to use this app:\"),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''1. If you want to find guides for a single CRISPR edit. For this use case, please enter \n            in your reference sequence and edited sequence in their respective input boxes.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''2. If you have more than one CRISPR edit you want to make, you can upload a CSV file with \n            two columns, named \"Reference Sequence\" and \"Edited Sequence\" that contain your reference and \n            edited sequences, with each row representing one edit you would like to make.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''After specifing your input, click the \"Find Guides\" button and editABLE will try to find CRISPR \n            guides that will induce your desired edits. Once editABLE finishes running, a table will appear \n            displaying either the guides that editABLE has found for each of your desired edits or a suggestion to \n            use an alternative CRISPR technology if base or prime editing guides can't be found. Lastly, you can \n            download a CSV of the guides found by editABLE by clicking on the \"Download Results as CSV File\" \n            button. Note that if you uploaded a large CSV file with many edits, you may have to wait awhile.'''\n        )\n    ),\n    ui_card(\n        \"Input requirements\",\n        ui.help_text(\n            '''Your reference sequence(s) and the edited sequence(s) must be the same length. Only single edits \n            (SNV, insertion, deletion) are supported at this time.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For single nucleotide variant (SNV) edits, the input sequences are the most straightforward. You can \n            input the reference and edited sequences in without modification. For example, this would be a valid set of inputs:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Reference Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"A\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Edited Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"T\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in deletions, use a string of \"-\" characters in the edited sequence to denote the \n            area of the deletion. For example, this would be a valid set of inputs for a deletion:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Reference Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"ATT\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Edited Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in insertions/duplications, use a string of \"-\" characters in the reference sequence \n            to denote the area of the insertion/duplication. For example, this would be a valid set of inputs for a insertions/duplications:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Reference Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Edited Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"GCG\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''Lastly, we require at least 25 base pairs of sequence to the left and right of your desired edit. \n            So in each of the examples above, there must be 25 or more base pairs to the right and left \n            of the red highlighted regions.'''\n        )\n    ),\n    ui_card(\n        \"Input\",\n        ui.input_text_area(\"ref_sequence_input\", \"Reference Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        ui.input_text_area(\"edited_sequence_input\", \"Edited Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        #ui.tags.a(ui.input_file(\"file1\", \"Choose a csv file of sequences to upload:\", accept='.csv', multiple=False, width=\"100%\"), {\"position\" : \"sticky\"}),\n        ui.input_file(\"file1\", \"Choose a CSV File of Sequences to Upload (note that clicking the button will cause the screen to scroll up to the top which is annoying and we are trying to fix that):\", accept='.csv', multiple=False, width=\"100%\"),\n        ui.input_action_button(\"get_guides\", \"Find Guides\", class_=\"btn-success\"),\n    ),\n    ui_card(\n        \"Results\",\n        ui.help_text(\n            \"Note: there can be more than one base editing guide for a single desired edit, but we will only show the recommended PrimeDesign prime editing guide\"\n        ),\n        ui.br(),\n        ui.br(),\n        ui.output_ui(\"run\")\n    ),\n    ui.help_text(\n        '''Note that we use PrimeDesign (Hsu, J.Y., Gr\u00fcnewald, J., Szalay, R. et al. \n        PrimeDesign software for rapid and simplified design of prime editing guide RNAs. \n        Nat Commun 12, 1034 (2021)) for prime editing guide calcualtions. We run PrimeDesign \n        with default parameters and take only the suggested guides. For more advanced usage \n        please use the ''',\n        ui.tags.a('PrimeDesign portal', {'href' : 'https://primedesign.pinellolab.partners.org/', 'target' : '_blank'}),\n        ''' (https://primedesign.pinellolab.partners.org/) to design your Prime Editing guides.'''\n    ),\n)\n\ndef check_ref_edited_pair(ref_sequence, edited_sequence):\n    if len(ref_sequence) == 0 or len(edited_sequence) == 0:\n        return False, \"Both the reference sequence and the edited sequence must be of nonzero length.\"\n    if len(ref_sequence) != len(edited_sequence):\n        return False, \"The length of the reference sequence and the edited sequence must be the same.\"\n    if ref_sequence == edited_sequence:\n        return False, \"The reference sequence and the edited sequence are the same.\"\n    if len(set(ref_sequence) - accepted_bases) != 0 or len(set(edited_sequence) - accepted_bases) != 0:\n        return False, \"You may only have the following characters in your sequences {A, C, G, T, -}.\"\n    if len(set(ref_sequence) - bases) == 0 and len(set(edited_sequence) - bases) == 0:\n        substitution_position = None\n        for i in range(len(ref_sequence)):\n            ref_base = ref_sequence[i]\n            edited_base = edited_sequence[i]\n            if ref_base != edited_base:\n                if substitution_position is not None:\n                    return False, \"The reference sequence and the edited sequence contain more than one SNV. You can only have one SNV edit.\"\n                else:\n                    substitution_position = i\n        if substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {substitution_position} base pairs were found before your edit.\"\n        if len(ref_sequence) - 1 - substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - substitution_position} base pairs were found after your edit.\"\n    else:\n        if '-' not in ref_sequence and '-' not in edited_sequence:\n            return False, 'The lengths of the reference sequence and the edited sequence are not the same but neither has a \"-\" in it.'\n        if '-' in ref_sequence and '-' in edited_sequence:\n            return False, 'You cannot have a \"-\" in both the reference and edited sequences.'\n        elif '-' in ref_sequence:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(ref_sequence)):\n                if ref_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple insertions. You can only have one insertion.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n        else:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(edited_sequence)):\n                if edited_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple insertions. You can only have one insertion.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n    return True, \"Inputs verified. Proceed to get guides.\"\n    \ndef server(input, output, session):    \n    MAX_SIZE = 1000\n    \n    def input_check(ref_sequence_input, edited_sequence_input, file_infos):\n        if file_infos and not (ref_sequence_input or edited_sequence_input):\n            uploaded_fule = file_infos[0]\n            try:\n                df = pd.read_csv(uploaded_fule['datapath'])\n            except:\n                return False, \"Input file is not a properly formed CSV file. Please input a proper CSV file.\"\n            #else:\n            if len(df.columns) != 2 and df.columns.tolist() != ['Reference Sequence', 'Edited Sequence']:\n                return False, 'Uploaded csv does not have the proper columns. Your csv must have two columns with names \"Reference Sequence\" and \"Edited Sequence\"'\n            counter = 1\n            for index, row in df.iterrows():\n                ref_sequence = row['Reference Sequence'].strip()\n                edited_sequence = row['Edited Sequence'].strip()\n                check, message = check_ref_edited_pair(ref_sequence, edited_sequence)\n                if not check:\n                    return check, f\"Error row {counter}: {message}\"\n                counter += 1\n            return True, \"Input CSV verified. Proceed to get guides.\"\n        elif ref_sequence_input and edited_sequence_input and not file_infos:\n            check, message = check_ref_edited_pair(ref_sequence_input.strip(), edited_sequence_input.strip())\n            return check, message\n        else:\n            return False, \"Error: Fill in both text input fields or upload a CSV file but do not do both.\"\n    \n    @output\n    @render.ui\n    @reactive.event(input.get_guides)\n    def run():\n        \n        @output\n        @render.data_frame\n        def render_results():\n            nonlocal to_display_guides_df\n            return render.DataGrid(\n                        to_display_guides_df,\n                        row_selection_mode='none',\n                        width=\"100%\",\n                        filters=False,\n                        summary = True,\n            )\n\n        @session.download(filename=lambda: f\"guides-{date.today().isoformat()}-{datetime.now().strftime('%H-%M-%S')}.csv\")\n        async def download_results():\n            nonlocal guides_df\n            yield guides_df.to_csv()\n            \n        ref_sequence_input = input.ref_sequence_input()\n        edited_sequence_input = input.edited_sequence_input()\n        file_infos = input.file1()\n\n        valid_inputs, message = input_check(ref_sequence_input, edited_sequence_input, file_infos)\n\n        if valid_inputs:\n            if file_infos and not (ref_sequence_input or edited_sequence_input):\n                uploaded_file = file_infos[0]\n                df = pd.read_csv(uploaded_file['datapath'])\n                dfs_to_merge_download = list()\n                dfs_to_merge_display = list()\n                counter = 1\n                \n                with ui.Progress(min=1, max=df.shape[0]) as p:\n                    p.set(message=\"Finding guides\", detail=\"This may take a while...\")\n                    for index, row in df.iterrows():\n                        p.set(counter, message=\"Finding guides\")\n                        ref_sequence_input = row['Reference Sequence'].strip()\n                        edited_sequence_input = row['Edited Sequence'].strip()\n                        guides_df = get_guides(ref_sequence_input, edited_sequence_input)\n                        to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input)\n                        index_column = [str(counter)] * to_display_guides_df.shape[0]\n                        to_display_guides_df.insert(loc=0, column='Input CSV Row Number', value=index_column)\n                        dfs_to_merge_download.append(guides_df)\n                        dfs_to_merge_display.append(to_display_guides_df)\n                        counter += 1\n\n                to_display_guides_df = pd.concat(dfs_to_merge_display)\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Edited Sequence'])\n                guides_df = pd.concat(dfs_to_merge_download)\n            elif ref_sequence_input and edited_sequence_input and not file_infos:\n                to_display_guides_df, guides_df = get_guides(ref_sequence_input.strip(), edited_sequence_input.strip())\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Edited Sequence'])\n            return ui.TagList(\n                ui.output_data_frame(\"render_results\"),\n                ui.br(),\n                ui.br(),\n                ui.download_button(\"download_results\", \"Download Results as CSV File\")\n            )\n        else:\n            return ui.div(ui.tags.b(message, style=\"color: red;\"))\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "utils.py", "content": "import collections\nimport pandas as pd\nimport regex as re\nfrom Bio.Seq import MutableSeq\nfrom Bio.SeqUtils import MeltingTemp as mt\nfrom math import log\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\n\nPAMs = re.compile(\"[A|T|G|C]G\")\nreverse_PAMs = re.compile(\"C[A|T|G|C]\")\nedit_start = 4\nedit_end = 8\ngRNA_size = 20\npam_length = 2\n\n\n# Random affine gap penalty scoring function\ndef gap_function(x, y):  # x is gap position in seq, y is gap length\n    if y == 0:  # No gap\n        return 0\n    elif y == 1:  # Gap open penalty\n        return -2\n    return - (2 + y / 4.0 + log(y) / 2.0)\n\n\n# Helper function to find guide RNAs for ABE and CBE editable mutations on forward/reverse strands\ndef find_BE_guide_rnas(direction, mutant_seq, genomic_location):\n    if direction == \"forward\":\n        start_pams = genomic_location + (gRNA_size - edit_end) + 1\n        end_pams = genomic_location + (gRNA_size - edit_start) + pam_length + 1\n        possible_pams = mutant_seq[start_pams : end_pams]\n        if len(re.findall(PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            for match in re.finditer(PAMs, str(possible_pams), overlapped=True):\n                gRNA = mutant_seq[start_pams + match.start() - gRNA_size: start_pams + match.start()]\n                guideRNAs.append(str(gRNA))\n            return guideRNAs\n\n    elif direction == \"reverse\":\n        start_pams = genomic_location - gRNA_size + edit_start - pam_length\n        end_pams = genomic_location - gRNA_size + edit_end\n        possible_pams = mutant_seq[start_pams : end_pams]\n        if len(re.findall(reverse_PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            for match in re.finditer(reverse_PAMs, str(possible_pams), overlapped=True):\n                gRNA = mutant_seq[start_pams + match.start() + pam_length : start_pams + match.start() + pam_length + gRNA_size]\n                gRNA.reverse_complement(inplace=True)\n                guideRNAs.append(str(gRNA))\n            return guideRNAs\n    else:\n        return \"ERROR\"\n\n\n# Helper function to find guide RNAs for transversion (C>G and G>C) mutations on forward/reverse strands\ndef find_trans_guide_rnas(direction, mutant_seq, genomic_location):\n    if direction == \"forward\":\n        pam = mutant_seq[genomic_location + 15 : genomic_location + 15 + pam_length]\n        if len(re.findall(PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            return mutant_seq[genomic_location + 15 - gRNA_size : genomic_location + 15]\n    elif direction == \"reverse\":\n        pam = mutant_seq[genomic_location - 15 - 1: genomic_location - 15 - 1 + pam_length]\n        if len(re.findall(reverse_PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            gRNA = mutant_seq[genomic_location - 15 - 1 + pam_length: genomic_location - 15 - 1 + pam_length + gRNA_size]\n            gRNA.reverse_complement(inplace=True)\n            return gRNA\n    else:\n        return \"ERROR\"\n\n\n# Adds the base editable guide RNAs to the data table for export\ndef get_guide_RNAs(mutant_seq, edit_type, genomic_location):\n    if edit_type == \"A>G\":\n        return find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n    elif edit_type == \"T>C\":\n        return find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n    elif edit_type == \"G>A\":\n        return find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n    elif edit_type == \"C>T\":\n        return find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n    elif edit_type == \"G>C\":\n        return find_trans_guide_rnas(\"forward\", mutant_seq, genomic_location)\n    elif edit_type == \"C>G\":\n        return find_trans_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n    else:\n        return \"NOT BASE EDITABLE\"\n\n\ndef get_guides(ref_sequence_original, edited_sequence_original):\n    ref_sequence = MutableSeq(ref_sequence_original)\n    edited_sequence = MutableSeq(edited_sequence_original)\n\n    df_dict = collections.defaultdict(list)\n    \n    if len(set(ref_sequence) - bases) == 0:\n            substitution_position = None\n            for i in range(len(ref_sequence)):\n                ref_base = ref_sequence[i]\n                edited_base = edited_sequence[i]\n                if ref_base != edited_base:\n                    substitution_position = i\n                    break\n            edit = f\"{ref_sequence[substitution_position]}>{edited_sequence[substitution_position]}\"\n            guide_rnas = get_guide_RNAs(edited_sequence, edit, substitution_position)\n            if guide_rnas == \"NOT BASE EDITABLE\" or guide_rnas == \"NO PAM\":                \n                primedesign_input = str(ref_sequence[:substitution_position] + f\"({ref_sequence[substitution_position]}/{edited_sequence[substitution_position]})\" + ref_sequence[substitution_position + 1:])\n                primedesign_output = run_primedesign(str(primedesign_input))\n                if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                    peg_spacer_top_recommended = primedesign_output[0]\n                    peg_spacer_bottom_recommended = primedesign_output[1]\n                    peg_ext_top_recommended = primedesign_output[2]\n                    peg_ext_bottom_recommended = primedesign_output[3]\n                    peg_annotation_recommended = primedesign_output[4]\n                    peg_pbs_recommended = primedesign_output[5]\n                    peg_rtt_recommended = primedesign_output[6]\n                    ng_spacer_top_recommended = primedesign_output[7]\n                    ng_spacer_bottom_recommended = primedesign_output[8]\n                    ng_annotation_recommended = primedesign_output[9]\n                    ng_distance_recommended = primedesign_output[10]\n                    \n                    df_dict['Original Sequence'].append(ref_sequence_original)\n                    df_dict['Edited Sequence'].append(edited_sequence_original)\n                    df_dict['Editing Technology'].append(\"Prime Editing\")\n                    df_dict['Base Editing Guide'].append(None)\n                    \n                    df_dict['PrimeDesign pegRNA Annotation'].append(peg_annotation_recommended)\n                    df_dict['PrimeDesign pegRNA PBS'].append(peg_pbs_recommended)\n                    df_dict['PrimeDesign pegRNA RTT'].append(peg_rtt_recommended)\n\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(peg_spacer_top_recommended)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(peg_spacer_bottom_recommended)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(peg_ext_top_recommended)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(peg_ext_bottom_recommended)\n                    \n                    df_dict['PrimeDesign ngRNA Annotation'].append(ng_annotation_recommended)\n                    df_dict['PrimeDesign ngRNA Distance'].append(ng_distance_recommended)\n\n                    df_dict['PrimeDesign ngRNA Oligo Top'].append(ng_spacer_top_recommended)\n                    df_dict['PrimeDesign ngRNA Bottom Top'].append(ng_spacer_bottom_recommended)\n                else:\n                    df_dict['Original Sequence'].append(ref_sequence_original)\n                    df_dict['Edited Sequence'].append(edited_sequence_original)\n                    df_dict['Editing Technology'].append(\"No Base or Prime Editing Guides Found\")\n                    df_dict['Base Editing Guide'].append(None)\n                    \n                    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                    df_dict['PrimeDesign pegRNA PBS'].append(None)\n                    df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                    \n                    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                    df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n                    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n            else:\n                if not isinstance(guide_rnas, list):\n                    guide_rnas = [guide_rnas]\n                for gRNA in guide_rnas:\n                    df_dict['Original Sequence'].append(ref_sequence_original)\n                    df_dict['Edited Sequence'].append(edited_sequence_original)\n                    df_dict['Editing Technology'].append(\"Base Editing\")\n                    df_dict['Base Editing Guide'].append(str(gRNA))\n\n                    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                    df_dict['PrimeDesign pegRNA PBS'].append(None)\n                    df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                    \n                    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                    df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n                    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n    # If the length of the reference sequence is less than the length of the edited sequence, there has been either an insertion or a duplication\n    elif '-' in ref_sequence:\n        insertion_start = ref_sequence.find('-')\n        insertion_end = ref_sequence.rfind('-')\n        if insertion_end - insertion_start + 1 > 44:\n            df_dict['Original Sequence'].append(ref_sequence_original)\n            df_dict['Edited Sequence'].append(edited_sequence_original)\n            df_dict['Editing Technology'].append(\"Use Twin Prime Editing/Integrase/HDR\")\n            df_dict['Base Editing Guide'].append(None)\n            \n            df_dict['PrimeDesign pegRNA Annotation'].append(None)\n            df_dict['PrimeDesign pegRNA PBS'].append(None)\n            df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n            df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n            df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n            df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n            df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n            \n            df_dict['PrimeDesign ngRNA Annotation'].append(None)\n            df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n            df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n            df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n        else:\n            primedesign_input = str(ref_sequence[:insertion_start] + f\"(+{edited_sequence[insertion_start : insertion_end + 1]})\" + ref_sequence[insertion_end + 1:])\n            primedesign_output = run_primedesign(primedesign_input)\n            if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                peg_spacer_top_recommended = primedesign_output[0]\n                peg_spacer_bottom_recommended = primedesign_output[1]\n                peg_ext_top_recommended = primedesign_output[2]\n                peg_ext_bottom_recommended = primedesign_output[3]\n                peg_annotation_recommended = primedesign_output[4]\n                peg_pbs_recommended = primedesign_output[5]\n                peg_rtt_recommended = primedesign_output[6]\n                ng_spacer_top_recommended = primedesign_output[7]\n                ng_spacer_bottom_recommended = primedesign_output[8]\n                ng_annotation_recommended = primedesign_output[9]\n                ng_distance_recommended = primedesign_output[10]\n\n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Edited Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Prime Editing\")\n                df_dict['Base Editing Guide'].append(None)\n                \n                df_dict['PrimeDesign pegRNA Annotation'].append(peg_annotation_recommended)\n                df_dict['PrimeDesign pegRNA PBS'].append(peg_pbs_recommended)\n                df_dict['PrimeDesign pegRNA RTT'].append(peg_rtt_recommended)\n\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(peg_spacer_top_recommended)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(peg_spacer_bottom_recommended)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(peg_ext_top_recommended)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(peg_ext_bottom_recommended)\n                \n                df_dict['PrimeDesign ngRNA Annotation'].append(ng_annotation_recommended)\n                df_dict['PrimeDesign ngRNA Distance'].append(ng_distance_recommended)\n\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(ng_spacer_top_recommended)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(ng_spacer_bottom_recommended)\n            else:\n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Edited Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Use Twin Prime Editing/Integrase/HDR\")\n                df_dict['Base Editing Guide'].append(None)\n                \n                df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                df_dict['PrimeDesign pegRNA PBS'].append(None)\n                df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                \n                df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n            \n    # If the length of the reference sequence is more than the length of the edited sequence, there has been a deletion\n    elif '-' in edited_sequence:\n        deletion_start = edited_sequence.find('-')\n        deletion_end = edited_sequence.rfind('-')\n        if deletion_start - deletion_end + 1 > 80:\n            df_dict['Original Sequence'].append(ref_sequence_original)\n            df_dict['Edited Sequence'].append(edited_sequence_original)\n            df_dict['Editing Technology'].append(\"Use Twin Prime Editing/Integrase/HDR\")\n            df_dict['Base Editing Guide'].append(None)\n            \n            df_dict['PrimeDesign pegRNA Annotation'].append(None)\n            df_dict['PrimeDesign pegRNA PBS'].append(None)\n            df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n            df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n            df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n            df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n            df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n            \n            df_dict['PrimeDesign ngRNA Annotation'].append(None)\n            df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n            df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n            df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n        else:\n            primedesign_input = str(ref_sequence[:deletion_start] + f\"(-{ref_sequence[deletion_start : deletion_end + 1]})\" + ref_sequence[deletion_end + 1:])\n            primedesign_output = run_primedesign(primedesign_input)\n            if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                peg_spacer_top_recommended = primedesign_output[0]\n                peg_spacer_bottom_recommended = primedesign_output[1]\n                peg_ext_top_recommended = primedesign_output[2]\n                peg_ext_bottom_recommended = primedesign_output[3]\n                peg_annotation_recommended = primedesign_output[4]\n                peg_pbs_recommended = primedesign_output[5]\n                peg_rtt_recommended = primedesign_output[6]\n                ng_spacer_top_recommended = primedesign_output[7]\n                ng_spacer_bottom_recommended = primedesign_output[8]\n                ng_annotation_recommended = primedesign_output[9]\n                ng_distance_recommended = primedesign_output[10]\n\n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Edited Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Prime Editing\")\n                df_dict['Base Editing Guide'].append(None)\n                \n                df_dict['PrimeDesign pegRNA Annotation'].append(peg_annotation_recommended)\n                df_dict['PrimeDesign pegRNA PBS'].append(peg_pbs_recommended)\n                df_dict['PrimeDesign pegRNA RTT'].append(peg_rtt_recommended)\n\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(peg_spacer_top_recommended)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(peg_spacer_bottom_recommended)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(peg_ext_top_recommended)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(peg_ext_bottom_recommended)\n                \n                df_dict['PrimeDesign ngRNA Annotation'].append(ng_annotation_recommended)\n                df_dict['PrimeDesign ngRNA Distance'].append(ng_distance_recommended)\n\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(ng_spacer_top_recommended)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(ng_spacer_bottom_recommended)\n            else:\n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Edited Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Use Twin Prime Editing/Integrase/HDR\")\n                df_dict['Base Editing Guide'].append(None)\n                \n                df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                df_dict['PrimeDesign pegRNA PBS'].append(None)\n                df_dict['PrimeDesign pegRNA RTT'].append(None)\n\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                \n                df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                df_dict['PrimeDesign ngRNA Distance'].append(None)\n\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n    \n    df_dict_render = collections.defaultdict(list)\n    for key in df_dict:\n        for value in df_dict[key]:\n            if key == 'Editing Technology' or key == 'PrimeDesign pegRNA Annotation':\n                df_dict_render[key].append(value)\n            elif value is None:\n                df_dict_render[key].append(None)\n            else:\n                key_len = len(key)\n                #value += len(value) % (key_len * \"B\"\n                new_value = '\\n'.join(value[i:i+key_len] for i in range(0, len(value), key_len))\n                #new_value += (len(value) % key_len) * \"*\"\n                #new_value += \"\\n\"\n                df_dict_render[key].append(new_value)\n    \n    return pd.DataFrame.from_dict(df_dict_render).dropna(how='all', axis=1), pd.DataFrame.from_dict(df_dict).dropna(how='all', axis=1)\n    #return pd.DataFrame.from_dict(df_dict).dropna(how='all', axis=1)\n\n# Helper functions\ndef gc_content(sequence):\n    sequence = sequence.upper()\n    GC_count = sequence.count('G') + sequence.count('C')\n    GC_content = float(GC_count)/float(len(sequence))\n\n    return(\"%.2f\" % GC_content)\n\n# IUPAC code map\niupac2bases_dict = {'A':'A','T':'T','C':'C','G':'G','a':'a','t':'t','c':'c','g':'g',\n'R':'[AG]','Y':'[CT]','S':'[GC]','W':'[AT]','K':'[GT]','M':'[AC]','B':'[CGT]','D':'[AGT]','H':'[ACT]','V':'[ACG]','N':'[ACTG]',\n'r':'[ag]','y':'[ct]','s':'[gc]','w':'[at]','k':'[gt]','m':'[ac]','b':'[cgt]','d':'[agt]','h':'[act]','v':'[acg]','n':'[actg]',\n'(':'(',')':')','+':'+','-':'-','/':'/'}\n\ndef iupac2bases(iupac):\n\n    try:\n        bases = iupac2bases_dict[iupac]\n    except:\n        logger.error('Symbol %s is not within the IUPAC nucleotide code ...' % str(iupac))\n        sys.exit(1)\n\n    return(bases)\n\n# Reverse complement function\ndef reverse_complement(sequence):\n    sequence = sequence\n    new_sequence = ''\n    for base in sequence:\n        if base == 'A':\n            new_sequence += 'T'\n        elif base == 'T':\n            new_sequence += 'A'\n        elif base == 'C':\n            new_sequence += 'G'\n        elif base == 'G':\n            new_sequence += 'C'\n        elif base == 'a':\n            new_sequence += 't'\n        elif base == 't':\n            new_sequence += 'a'\n        elif base == 'c':\n            new_sequence += 'g'\n        elif base == 'g':\n            new_sequence += 'c'\n        elif base == '[':\n            new_sequence += ']'\n        elif base == ']':\n            new_sequence += '['\n        elif base == '+':\n            new_sequence += '+'\n        elif base == '-':\n            new_sequence += '-'\n        elif base == '/':\n            new_sequence += '/'\n        elif base == '(':\n            new_sequence += ')'\n        elif base == ')':\n            new_sequence += '('\n    return(new_sequence[::-1])\n\n# Extract reference and edited sequence information\ndef process_sequence(input_sequence):\n\n    input_sequence = ''.join(input_sequence.split())\n\n    # Check formatting is correct\n    format_check = ''\n    for i in input_sequence:\n        if i == '(':\n            format_check += '('\n        elif i == ')':\n            format_check += ')'\n        elif i == '/':\n            format_check += '/'\n        elif i == '+':\n            format_check += '+'\n        elif i == '-':\n            format_check += '-'\n\n    # Check composition of input sequence\n    if len(input_sequence) != sum([1 if x in ['A','T','C','G','(',')','+','-','/'] else 0 for x in input_sequence.upper()]):\n        assert False\n\n    # Check formatting\n    if format_check.count('(') == format_check.count(')') and format_check.count('(') > 0: # Left and right parantheses equal\n        if '((' not in format_check: # Checks both directions for nested parantheses\n            if '()' not in format_check: # Checks for empty annotations\n                if sum([1 if x in format_check else 0 for x in ['++','--','//','+-','+/','-+','-/','/+','/-','/(','+(','-(',')/',')+',')-']]) == 0:\n                    pass\n\n    # Create mapping between input format and reference and edit sequence\n    editformat2sequence = {}\n    edits = re.findall('\\(.*?\\)', input_sequence)\n    for edit in edits:\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','')]\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','')]\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '']\n\n    # Create mapping between edit number and reference and edit sequence\n    editformat2sequence = {}\n    editnumber2sequence = {}\n    edit_idxs = [[m.start(), m.end()] for m in re.finditer('\\(.*?\\)', input_sequence)]\n    edit_counter = 1\n    for edit_idx in edit_idxs:\n        edit = input_sequence[edit_idx[0]:edit_idx[1]]\n\n        # Create edit format and number to sequence map\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower()]\n\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = ['' , edit.split('+')[1].replace(')','').lower()]\n\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '', edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('-')[1].replace(')',''), '']\n\n        edit_counter += 1\n\n    edit_start = min([i.start() for i in re.finditer('\\(', input_sequence)])\n    edit_stop = max([i.start() for i in re.finditer('\\)', input_sequence)])\n\n    edit_span_sequence_w_ref = input_sequence[edit_start:edit_stop + 1]\n    edit_span_sequence_w_edit = input_sequence[edit_start:edit_stop + 1]\n    for edit in editformat2sequence:\n        edit_span_sequence_w_ref = edit_span_sequence_w_ref.replace(edit, editformat2sequence[edit][0])\n        edit_span_sequence_w_edit = edit_span_sequence_w_edit.replace(edit, editformat2sequence[edit][1])\n\n    edit_start_in_ref = re.search('\\(', input_sequence).start()\n    edit_stop_in_ref_rev = re.search('\\)', input_sequence[::-1]).start()\n\n    edit_span_length_w_ref = len(edit_span_sequence_w_ref)\n    edit_span_length_w_edit = len(edit_span_sequence_w_edit)\n\n    reference_sequence = input_sequence\n    edit_sequence = input_sequence\n    editnumber_sequence = input_sequence\n    for edit in editformat2sequence:\n        reference_sequence = reference_sequence.replace(edit, editformat2sequence[edit][0])\n        edit_sequence = edit_sequence.replace(edit, editformat2sequence[edit][1])\n        editnumber_sequence = editnumber_sequence.replace(edit, str(editformat2sequence[edit][2]))\n\n    return(editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev)\n\ndef run_primedesign(input_sequence):\n    target_design = {}\n    peg_design = {'pegRNA group':[],'type':[], 'spacer sequence':[],'spacer GC content':[],'PAM':[],'strand':[],'peg-to-edit distance':[],'nick-to-peg distance':[],'pegRNA extension':[], 'extension first base':[],'PBS length':[],'PBS GC content':[], 'PBS Tm':[], 'RTT length':[],'RTT GC content':[],'annotation':[],'spacer top strand oligo':[], 'spacer bottom strand oligo':[], 'pegRNA extension top strand oligo':[], 'pegRNA extension bottom strand oligo':[], 'CFD score':[]}\n\n    input_sequence = ''.join(input_sequence.split())\n    pe_format = 'NNNNNNNNNNNNNNNNN/NNN[NGG]'\n    \n    pbs_length_list = list(range(12, 15))\n    rtt_length_list = list(range(10, 21))\n\n    if 80 not in rtt_length_list:\n        rtt_length_list.append(80)\n        rtt_length_list = sorted(rtt_length_list)\n\n    nicking_distance_minimum = 0\n    nicking_distance_maximum = 100\n\n    target_sequence = input_sequence\n    target_name = 'user-input'\n\n    target_sequence = target_sequence.upper()\n    editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev = process_sequence(target_sequence)\n\n    # Initialize dictionary for the design of pegRNA spacers for each target sequence and intended edit(s)\n    target_design[target_name] = {'target_sequence':target_sequence, 'editformat2sequence': editformat2sequence, 'editnumber2sequence': editnumber2sequence, 'reference_sequence': reference_sequence, 'edit_sequence': edit_sequence, 'editnumber_sequence': editnumber_sequence, 'edit_span_length': [edit_span_length_w_ref, edit_span_length_w_edit], 'edit_start_in_ref': edit_start_in_ref, 'edit_stop_in_ref_rev': edit_stop_in_ref_rev, 'pegRNA':{'+':[], '-':[]}, 'ngRNA':{'+':[], '-':[]}}\n\n    # Find indices but shift when removing annotations\n    cut_idx = re.search('/', pe_format).start()\n    pam_start_idx = re.search('\\[', pe_format).start()\n    pam_end_idx = re.search('\\]', pe_format).start()\n\n    # Find pam and total PE format search length\n    pam_length = pam_end_idx - pam_start_idx - 1\n    pe_format_length = len(pe_format) - 3\n\n    # Check if cut site is left of PAM\n    if cut_idx < pam_start_idx:\n\n        # Shift indices with removal of annotations\n        pam_start_idx = pam_start_idx - 1\n        pam_end_idx = pam_end_idx - 2\n        spacer_start_idx = 0\n        spacer_end_idx = pam_start_idx\n\n    else:\n        pam_end_idx = pam_end_idx - 1\n        cut_idx = cut_idx - 2\n        spacer_start_idx = pam_end_idx\n        spacer_end_idx = len(pe_format) - 3\n\n    # Remove annotations and convert into regex\n    pe_format_rm_annotation = pe_format.replace('/', '').replace('[', '').replace(']', '')\n\n    # Create PE format and PAM search sequences\n    pe_format_search_plus = ''\n    for base in pe_format_rm_annotation:\n        pe_format_search_plus += iupac2bases(base)\n    pe_format_search_minus = reverse_complement(pe_format_search_plus)\n\n    pam_search = ''\n    pam_sequence = pe_format_rm_annotation[pam_start_idx:pam_end_idx]\n    for base in pam_sequence:\n        pam_search += iupac2bases(base)\n\n    ##### Initialize data storage for output\n    counter = 1\n    for target_name in target_design:\n\n        # pegRNA spacer search for (+) and (-) strands with reference sequence\n        reference_sequence = target_design[target_name]['reference_sequence']\n        find_guides_ref_plus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_plus, reference_sequence, re.IGNORECASE)]\n        find_guides_ref_minus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_minus, reference_sequence, re.IGNORECASE)]\n\n        # pegRNA spacer search for (+) and (-) strands with edit number sequence\n        editnumber_sequence = target_design[target_name]['editnumber_sequence']\n        find_guides_editnumber_plus = [[m.start()] for m in re.finditer('(?=%s)' % pam_search.replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n        find_guides_editnumber_minus = [[m.start()] for m in re.finditer('(?=%s)' % reverse_complement(pam_search).replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n\n        # Find pegRNA spacers targeting (+) strand\n        if find_guides_ref_plus:\n\n            for match in find_guides_ref_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[spacer_start_idx:spacer_end_idx]\n                extension_core_sequence = full_search[:cut_idx]\n                downstream_sequence_ref = full_search[cut_idx:]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pam_start_idx:pam_end_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_end_idx:extension_core_end_idx + downstream_sequence_length]\n                    pam_edit = edit_sequence[extension_core_start_idx:extension_core_start_idx + pe_format_length][pam_start_idx:pam_end_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(pam_search, pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + cut_idx\n                    nick_edit_idx = extension_core_start_idx + cut_idx\n                    target_design[target_name]['pegRNA']['+'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find pegRNA spacers targeting (-) strand\n        if find_guides_ref_minus:\n\n            for match in find_guides_ref_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                extension_core_sequence = full_search[pe_format_length - cut_idx:]\n                downstream_sequence_ref = full_search[:pe_format_length - cut_idx]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_start_idx - downstream_sequence_length:extension_core_start_idx]\n                    pam_edit = edit_sequence[extension_core_end_idx - pe_format_length:extension_core_end_idx][pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(reverse_complement(pam_search), pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + (pe_format_length - cut_idx)\n                    nick_edit_idx = extension_core_start_idx - downstream_sequence_length + (pe_format_length - cut_idx)\n                    target_design[target_name]['pegRNA']['-'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find ngRNA spacers targeting (+) strand\n        if find_guides_editnumber_plus:\n\n            for match in find_guides_editnumber_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[:match[0] + pam_length]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[-pe_format_length:]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[-pe_format_length:]\n                    spacer_sequence_edit = full_search_edit[spacer_start_idx:spacer_end_idx]\n                    pam_edit = full_search_edit[pam_start_idx:pam_end_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[-pe_format_length:]\n                    spacer_sequence_ref = full_search_ref[spacer_start_idx:spacer_end_idx]\n                    pam_ref = full_search_ref[pam_start_idx:pam_end_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[-10:] == spacer_sequence_ref.upper()[-10:]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).end() - (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['+'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Find ngRNA spacers targeting (-) strand\n        if find_guides_editnumber_minus:\n\n            for match in find_guides_editnumber_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[match[0]:]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[:pe_format_length]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[:pe_format_length]\n                    spacer_sequence_edit = full_search_edit[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_edit = full_search_edit[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[:pe_format_length]\n                    spacer_sequence_ref = full_search_ref[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_ref = full_search_ref[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[:10] == spacer_sequence_ref.upper()[:10]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).start() + (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['-'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Grab index information of edits to introduce to target sequence\n        edit_start_in_ref = int(target_design[target_name]['edit_start_in_ref'])\n        edit_stop_in_ref_rev = int(target_design[target_name]['edit_stop_in_ref_rev'])\n        edit_span_length_w_ref = int(target_design[target_name]['edit_span_length'][0])\n        edit_span_length_w_edit = int(target_design[target_name]['edit_span_length'][1])\n\n        # Design pegRNAs targeting the (+) strand\n        counter = 1\n        counted = []\n        for peg_plus in target_design[target_name]['pegRNA']['+']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_plus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '+']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_start_in_ref - pe_nick_ref_idx\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            if ((len(edit_sequence) - pe_nick_edit_idx) - rtt_length) < 0:\n                                rtt_length = len(edit_sequence) - pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = reverse_complement(edit_sequence[pe_nick_edit_idx - pbs_length:pe_nick_edit_idx + rtt_length])\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(pe_spacer_sequence)\n                                peg_design['spacer GC content'].append(gc_content(pe_spacer_sequence))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(pe_pam_ref)\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('+')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if pe_spacer_sequence[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(pe_spacer_sequence))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + pe_spacer_sequence))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (-) strand for (+) pegRNAs\n                if counter in counted:\n                    for ng_minus in target_design[target_name]['ngRNA']['-']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_minus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(reverse_complement(ng_spacer_sequence_edit))\n                            peg_design['spacer GC content'].append(gc_content(reverse_complement(ng_spacer_sequence_edit)))\n                            peg_design['PAM'].append(reverse_complement(ng_pam_edit))\n                            peg_design['strand'].append('-')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if reverse_complement(ng_spacer_sequence_edit)[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(reverse_complement(ng_spacer_sequence_edit)))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + reverse_complement(ng_spacer_sequence_edit)))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n        # Design pegRNAs targeting the (-) strand\n        for peg_minus in target_design[target_name]['pegRNA']['-']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_minus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '-']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_stop_in_ref_rev - (len(reference_sequence) - pe_nick_ref_idx)\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            # pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n                            if (pe_nick_edit_idx - rtt_length) < 0:\n                                rtt_length = pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(reverse_complement(pe_spacer_sequence))\n                                peg_design['spacer GC content'].append(gc_content(reverse_complement(pe_spacer_sequence)))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(reverse_complement(pe_pam_ref))\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('-')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if reverse_complement(pe_spacer_sequence)[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(reverse_complement(pe_spacer_sequence)))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + reverse_complement(pe_spacer_sequence)))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (+) strand for (-) pegRNAs\n                if counter in counted:\n                    for ng_plus in target_design[target_name]['ngRNA']['+']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_plus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(ng_spacer_sequence_edit)\n                            peg_design['spacer GC content'].append(gc_content(ng_spacer_sequence_edit))\n                            peg_design['PAM'].append(ng_pam_edit)\n                            peg_design['strand'].append('+')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if ng_spacer_sequence_edit[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(ng_spacer_sequence_edit))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + ng_spacer_sequence_edit))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n    df = pd.DataFrame.from_dict(peg_design)\n\n    try:\n        df = df[~df['spacer sequence'].str.contains('TTTT')]\n    except:\n        pass\n\n    df_pegs = df[df['type'] == 'pegRNA']\n\n    # Find recommended pegRNA\n    if len(df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group']) > 0:\n\n        edit_effective_length = max([edit_span_length_w_ref, edit_span_length_w_edit])\n        if edit_effective_length <= 1:\n            homology_downstream_recommended = 9\n        elif edit_effective_length <= 5:\n            homology_downstream_recommended = 14\n        elif edit_effective_length <= 10:\n            homology_downstream_recommended = 19\n        elif edit_effective_length <= 15:\n            homology_downstream_recommended = 24\n        else:\n            homology_downstream_recommended = 34\n\n        pegrna_group = df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group'].values[0]\n        rtt_length_recommended = min(df_pegs[df_pegs['pegRNA group'] == pegrna_group]['peg-to-edit distance']) + homology_downstream_recommended\n        rtt_max = max(df_pegs[(df_pegs['pegRNA group'] == pegrna_group)]['RTT length'].values)\n\n        # find recommended PBS\n        df_pegs['recommended_PBS_Tm'] = abs(df_pegs['PBS Tm'] - 37) # optimal PBS Tm of 37C\n        pbs_length_recommended = df_pegs[df_pegs['pegRNA group'] == pegrna_group].sort_values(['recommended_PBS_Tm'], ascending = [True])['PBS length'].values[0]\n\n        # find recommended RTT\n        extension_first_base = 'C'\n        while (extension_first_base == 'C') and (rtt_length_recommended < rtt_max):\n            rtt_length_recommended += 1\n            extension_first_base = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max-int(rtt_length_recommended):rtt_max][0]\n\n        if extension_first_base != 'C':\n\n            pbs_extension_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max:]\n            rtt_extension_max = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][:rtt_max]\n            extension_recommended = rtt_extension_max[-rtt_length_recommended:] + pbs_extension_recommended\n\n            peg_spacer_top_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer top strand oligo'].values[0]\n            peg_spacer_bottom_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer bottom strand oligo'].values[0]\n            peg_ext_top_recommended = 'gtgc' + extension_recommended\n            peg_ext_bottom_recommended = 'aaaa' + reverse_complement(extension_recommended)\n\n            peg_annotation_recommended = ' %s' % str(df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['annotation'].values[0]).replace('_', ' ')\n            peg_pbs_recommended = '%s nt' % str(pbs_length_recommended)\n            peg_rtt_recommended = '%s nt' % str(rtt_length_recommended)\n\n            # Find recommended ngRNA\n            df_ngs = df[(df['type'] == 'ngRNA') & (df['pegRNA group'] == pegrna_group)]\n            df_ngs['optimal_distance'] = abs(abs(df_ngs['nick-to-peg distance']) - 75) # optimal ngRNA +/- 75 bp away\n            df_ngs = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True]) # prioritize PE3b\n\n            if len(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo']) > 0:\n\n                ng_spacer_top_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo'].values[0]\n                ng_spacer_bottom_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer bottom strand oligo'].values[0]\n                ng_annotation_recommended = ' %s' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['annotation'].values[0]).replace('_', ' ')\n                ng_distance_recommended = ' %s bp' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['nick-to-peg distance'].values[0])\n\n            else:\n\n                ng_spacer_top_recommended = 'n/a'\n                ng_spacer_bottom_recommended = 'n/a'\n                ng_annotation_recommended = 'n/a'\n                ng_distance_recommended = 'n/a'\n\n        else:\n\n            peg_spacer_top_recommended = 'n/a'\n            peg_spacer_bottom_recommended = 'n/a'\n            peg_ext_top_recommended = 'n/a'\n            peg_ext_bottom_recommended = 'n/a'\n\n            peg_annotation_recommended = ' n/a'\n            peg_pbs_recommended = ' n/a'\n            peg_rtt_recommended = ' n/a'\n\n            ng_spacer_top_recommended = 'n/a'\n            ng_spacer_bottom_recommended = 'n/a'\n            ng_annotation_recommended = ' n/a'\n            ng_distance_recommended = ' n/a'\n\n    else:\n\n        peg_spacer_top_recommended = ''\n        peg_spacer_bottom_recommended = ''\n        peg_ext_top_recommended = ''\n        peg_ext_bottom_recommended = ''\n\n        peg_annotation_recommended = ''\n        peg_pbs_recommended = ''\n        peg_rtt_recommended = ''\n\n        ng_spacer_top_recommended = ''\n        ng_spacer_bottom_recommended = ''\n        ng_annotation_recommended = ''\n        ng_distance_recommended = ''\n\n    '''\n    # Filter dataframes\n    df = df[(df['extension first base'] != 'C')]\n\n    pbs_range_list = list(range(12, 14 + 1)) + ['']\n    rtt_range_list = list(range(10, 20 + 1)) + ['']\n\n    pegrna_groups_to_keep = list(set(df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]['pegRNA group'].values))\n\n    df = df[df['PBS length'].isin(pbs_range_list)]\n    df_pegs = df_pegs[df_pegs['PBS length'].isin(pbs_range_list)]\n\n    df = df[df['RTT length'].isin(rtt_range_list)]\n    df_pegs = df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]\n\n    df = df[df['pegRNA group'].isin(pegrna_groups_to_keep)]\n    df_pegs = df_pegs[df_pegs['pegRNA group'].isin(pegrna_groups_to_keep)]\n\n    df.reset_index(drop=True, inplace=True)\n\n    df_pegs = df_pegs[['pegRNA group','spacer sequence','PAM','strand','peg-to-edit distance','spacer GC content','annotation']].drop_duplicates()\n    df_pegs = df_pegs.sort_values('peg-to-edit distance')\n    df_pegs.reset_index(drop=True, inplace=True)\n    #return df_pegs, df, peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended\n    '''\n    if peg_spacer_top_recommended == '' and peg_spacer_bottom_recommended == '' and peg_ext_top_recommended == '' and peg_ext_bottom_recommended == '' and peg_annotation_recommended == '' and peg_pbs_recommended == '' and peg_rtt_recommended == '' and ng_spacer_top_recommended == '' and ng_spacer_bottom_recommended == '' and ng_annotation_recommended == '' and ng_distance_recommended == '':\n        return \"No PrimeDesign Recommended Guides\"\n    elif peg_spacer_top_recommended == 'n/a' and peg_spacer_bottom_recommended == 'n/a' and peg_ext_top_recommended == 'n/a' and peg_ext_bottom_recommended == 'n/a' and peg_annotation_recommended == ' n/a' and peg_pbs_recommended == ' n/a' and peg_rtt_recommended == ' n/a' and ng_spacer_top_recommended == 'n/a' and ng_spacer_bottom_recommended == 'n/a' and ng_annotation_recommended == ' n/a' and ng_distance_recommended == ' n/a':\n        return \"No PrimeDesign Recommended Guides\"\n    else:\n        return (peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended)\n", "type": "text"}]